{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Setup Core Project Structure and HealthKit Integration",
        "description": "Initialize the iOS project with SwiftUI, configure HealthKit permissions, and implement the HealthKitManager to access health data types.",
        "details": "Create a new iOS project using SwiftUI and Swift Package Manager. Set up the project structure following MVVM architecture. Configure the Info.plist with necessary HealthKit permissions (NSHealthShareUsageDescription, NSHealthUpdateUsageDescription). Implement HealthKitManager class that:\n1. Requests authorization for all available HealthKit data types\n2. Queries available HKQuantityTypeIdentifiers\n3. Implements methods to fetch sample data for each type\n\nUse Swift 5.7+ and iOS 16+ as the deployment target. Leverage async/await for asynchronous operations. Include proper error handling and permission management.\n\nCode example for HealthKitManager:\n```swift\nimport HealthKit\n\nclass HealthKitManager {\n    static let shared = HealthKitManager()\n    private let healthStore = HKHealthStore()\n    \n    func requestAuthorization() async throws -> Bool {\n        guard HKHealthStore.isHealthDataAvailable() else {\n            throw HealthKitError.notAvailable\n        }\n        \n        // Request all readable types\n        let allTypes = HKObjectType.allReadableTypes()\n        return try await healthStore.requestAuthorization(toShare: [], read: Set(allTypes))\n    }\n    \n    func fetchAvailableDataTypes() -> [HKQuantityTypeIdentifier] {\n        // Return all available quantity types\n        return HKQuantityTypeIdentifier.allCases.filter { type in\n            // Filter to only include types that are accessible\n            return healthStore.authorizationStatus(for: HKObjectType.quantityType(forIdentifier: type)!) == .sharingAuthorized\n        }\n    }\n    \n    func fetchSamples(for typeIdentifier: HKQuantityTypeIdentifier, startDate: Date, endDate: Date) async throws -> [HKSample] {\n        let type = HKObjectType.quantityType(forIdentifier: typeIdentifier)!\n        let predicate = HKQuery.predicateForSamples(withStart: startDate, end: endDate, options: .strictStartDate)\n        \n        return try await withCheckedThrowingContinuation { continuation in\n            let query = HKSampleQuery(sampleType: type, predicate: predicate, limit: HKObjectQueryNoLimit, sortDescriptors: nil) { _, samples, error in\n                if let error = error {\n                    continuation.resume(throwing: error)\n                    return\n                }\n                continuation.resume(returning: samples ?? [])\n            }\n            healthStore.execute(query)\n        }\n    }\n}\n\nenum HealthKitError: Error {\n    case notAvailable\n    case authorizationFailed\n    case queryFailed\n}\n```",
        "testStrategy": "Create unit tests using XCTest framework to verify:\n1. HealthKit availability detection\n2. Authorization request flow (using mock HealthStore)\n3. Data type enumeration\n4. Sample query functionality\n\nCreate UI tests to verify permission dialogs appear correctly. Test on both physical devices and simulators to ensure proper HealthKit integration.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Implement HealthMetric Data Model and Normalization Layer",
        "description": "Create the HealthMetric data model and implement a normalization layer to standardize different HealthKit data types into a unified format.",
        "details": "Develop the HealthMetric model as specified in the PRD to standardize all health data types. Implement a normalization layer that converts HKSamples to HealthMetric objects.\n\n1. Create the HealthMetric struct:\n```swift\nstruct HealthMetric: Identifiable, Codable {\n    let id = UUID()\n    let name: String           // Human-readable name\n    let identifier: String     // HKQuantityTypeIdentifier string\n    let value: Double\n    let unit: String           // Standardized unit string\n    let timestamp: Date\n    \n    // Optional metadata\n    var source: String?        // App or device that recorded the data\n    var category: MetricCategory\n    \n    enum MetricCategory: String, Codable, CaseIterable {\n        case vitals\n        case activity\n        case nutrition\n        case sleep\n        case lab\n        case other\n    }\n}\n```\n\n2. Create a MetricNormalizer class that:\n   - Maps HKQuantityTypeIdentifiers to appropriate categories\n   - Converts HKSamples to HealthMetric objects with standardized units\n   - Handles edge cases like cumulative vs. discrete samples\n\n```swift\nclass MetricNormalizer {\n    static func categorizeMetric(_ identifier: HKQuantityTypeIdentifier) -> HealthMetric.MetricCategory {\n        switch identifier {\n        case .heartRate, .bloodPressureSystolic, .bloodPressureDiastolic, .respiratoryRate, .bodyTemperature:\n            return .vitals\n        case .stepCount, .distanceWalkingRunning, .activeEnergyBurned, .flightsClimbed:\n            return .activity\n        // Add other mappings\n        default:\n            return .other\n        }\n    }\n    \n    static func normalizeQuantitySample(_ sample: HKQuantitySample) -> HealthMetric {\n        let typeIdentifier = sample.quantityType.identifier\n        let value = normalizedValue(for: sample)\n        let unit = normalizedUnit(for: sample.quantityType)\n        \n        return HealthMetric(\n            name: humanReadableName(for: typeIdentifier),\n            identifier: typeIdentifier,\n            value: value,\n            unit: unit,\n            timestamp: sample.startDate,\n            source: sample.sourceRevision.source.name,\n            category: categorizeMetric(HKQuantityTypeIdentifier(rawValue: typeIdentifier))\n        )\n    }\n    \n    // Helper methods for normalization\n    private static func normalizedValue(for sample: HKQuantitySample) -> Double {\n        // Convert to standardized units based on type\n        let type = sample.quantityType\n        if type.identifier == HKQuantityTypeIdentifier.heartRate.rawValue {\n            return sample.quantity.doubleValue(for: HKUnit.count().unitDivided(by: HKUnit.minute()))\n        }\n        // Add other type conversions\n        return 0.0 // Placeholder\n    }\n    \n    private static func normalizedUnit(for quantityType: HKQuantityType) -> String {\n        // Return standardized unit string\n        if quantityType.identifier == HKQuantityTypeIdentifier.heartRate.rawValue {\n            return \"bpm\"\n        }\n        // Add other unit mappings\n        return \"\" // Placeholder\n    }\n    \n    private static func humanReadableName(for typeIdentifier: String) -> String {\n        // Convert identifiers to human-readable names\n        switch typeIdentifier {\n        case HKQuantityTypeIdentifier.heartRate.rawValue:\n            return \"Heart Rate\"\n        // Add other name mappings\n        default:\n            return typeIdentifier\n        }\n    }\n}\n```",
        "testStrategy": "Create comprehensive unit tests to verify:\n1. Correct categorization of all supported HealthKit types\n2. Accurate conversion from HKSamples to HealthMetric objects\n3. Proper unit standardization for different metric types\n4. Edge case handling (null values, unusual units)\n\nTest with mock HKSamples representing various health data types. Verify serialization/deserialization of HealthMetric objects.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Develop Basic UI and Navigation Structure",
        "description": "Create the app's main UI structure with tab navigation, including metric selection screen, logs screen, and settings screen.",
        "details": "Implement the core UI structure using SwiftUI with a TabView for main navigation. Create the following screens:\n\n1. Main TabView with icons and labels:\n```swift\nstruct ContentView: View {\n    var body: some View {\n        TabView {\n            MetricsSelectionView()\n                .tabItem {\n                    Label(\"Metrics\", systemImage: \"heart.text.square\")\n                }\n            \n            SyncDestinationsView()\n                .tabItem {\n                    Label(\"Destinations\", systemImage: \"arrow.triangle.branch\")\n                }\n            \n            LogsView()\n                .tabItem {\n                    Label(\"Logs\", systemImage: \"doc.text.magnifyingglass\")\n                }\n            \n            SettingsView()\n                .tabItem {\n                    Label(\"Settings\", systemImage: \"gear\")\n                }\n        }\n    }\n}\n```\n\n2. MetricsSelectionView with grouped toggles:\n```swift\nstruct MetricsSelectionView: View {\n    @StateObject private var viewModel = MetricsSelectionViewModel()\n    \n    var body: some View {\n        NavigationView {\n            List {\n                ForEach(HealthMetric.MetricCategory.allCases, id: \\.self) { category in\n                    Section(header: Text(category.rawValue.capitalized)) {\n                        ForEach(viewModel.availableMetrics.filter { $0.category == category }) { metric in\n                            MetricToggleRow(metric: metric, isSelected: viewModel.isSelected(metric))\n                                .onTapGesture {\n                                    viewModel.toggleMetric(metric)\n                                }\n                        }\n                    }\n                }\n            }\n            .navigationTitle(\"Health Metrics\")\n            .toolbar {\n                Button(\"Sync Now\") {\n                    viewModel.triggerSync()\n                }\n                .disabled(viewModel.selectedMetrics.isEmpty)\n            }\n        }\n        .onAppear {\n            Task {\n                await viewModel.loadAvailableMetrics()\n            }\n        }\n    }\n}\n```\n\n3. Create placeholder views for other tabs (SyncDestinationsView, LogsView, SettingsView)\n\n4. Implement supporting UI components:\n   - MetricToggleRow for selection UI\n   - CategoryHeader for section headers\n   - SyncButton with loading state\n   - EmptyStateView for when no metrics are available\n\nUse SF Symbols for icons and follow iOS Human Interface Guidelines. Implement proper loading states, error handling, and empty states for all views. Use SwiftUI's environment objects for sharing data between views.",
        "testStrategy": "Create UI tests using XCUITest to verify:\n1. Tab navigation works correctly\n2. Metric selection toggles function properly\n3. UI adapts to different device sizes and orientations\n4. Accessibility features work correctly (VoiceOver, Dynamic Type)\n\nCreate snapshot tests for UI components to ensure visual consistency. Test on multiple device sizes (iPhone and iPad) to verify responsive layout.",
        "priority": "high",
        "dependencies": [
          1,
          2
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Implement Metric Selection and Configuration Service",
        "description": "Create the ConfigService to store user settings and implement the metric selection functionality with persistence.",
        "details": "Develop the ConfigService to manage user settings and selected metrics. Implement persistence using UserDefaults and Keychain for sensitive data.\n\n1. Create UserSettings model:\n```swift\nstruct UserSettings: Codable {\n    var selectedMetricIdentifiers: [String] = []\n    var syncFrequency: SyncFrequency = .manual\n    var lastSyncDate: Date?\n    \n    enum SyncFrequency: String, Codable {\n        case manual\n        case daily\n        case hourly\n    }\n}\n```\n\n2. Implement ConfigService for settings management:\n```swift\nclass ConfigService {\n    static let shared = ConfigService()\n    \n    private let userDefaults = UserDefaults.standard\n    private let settingsKey = \"healthsync.userSettings\"\n    \n    private(set) var settings: UserSettings {\n        get {\n            if let data = userDefaults.data(forKey: settingsKey),\n               let settings = try? JSONDecoder().decode(UserSettings.self, from: data) {\n                return settings\n            }\n            return UserSettings()\n        }\n        set {\n            if let data = try? JSONEncoder().encode(newValue) {\n                userDefaults.set(data, forKey: settingsKey)\n            }\n        }\n    }\n    \n    func updateSettings(_ newSettings: UserSettings) {\n        settings = newSettings\n    }\n    \n    func selectMetric(_ identifier: String) {\n        var updatedSettings = settings\n        if !updatedSettings.selectedMetricIdentifiers.contains(identifier) {\n            updatedSettings.selectedMetricIdentifiers.append(identifier)\n            updateSettings(updatedSettings)\n        }\n    }\n    \n    func deselectMetric(_ identifier: String) {\n        var updatedSettings = settings\n        updatedSettings.selectedMetricIdentifiers.removeAll { $0 == identifier }\n        updateSettings(updatedSettings)\n    }\n    \n    func isMetricSelected(_ identifier: String) -> Bool {\n        return settings.selectedMetricIdentifiers.contains(identifier)\n    }\n    \n    func updateLastSyncDate() {\n        var updatedSettings = settings\n        updatedSettings.lastSyncDate = Date()\n        updateSettings(updatedSettings)\n    }\n}\n```\n\n3. Create MetricsSelectionViewModel to connect UI with ConfigService:\n```swift\nclass MetricsSelectionViewModel: ObservableObject {\n    @Published var availableMetrics: [HealthMetric] = []\n    @Published var isLoading = false\n    @Published var error: Error?\n    \n    private let healthKitManager = HealthKitManager.shared\n    private let configService = ConfigService.shared\n    \n    var selectedMetrics: [HealthMetric] {\n        return availableMetrics.filter { isSelected($0) }\n    }\n    \n    func loadAvailableMetrics() async {\n        DispatchQueue.main.async {\n            self.isLoading = true\n        }\n        \n        do {\n            // Request authorization if needed\n            let authorized = try await healthKitManager.requestAuthorization()\n            guard authorized else {\n                throw HealthKitError.authorizationFailed\n            }\n            \n            // Get available types\n            let typeIdentifiers = healthKitManager.fetchAvailableDataTypes()\n            \n            // Create placeholder metrics for UI\n            let metrics = typeIdentifiers.map { identifier in\n                return HealthMetric(\n                    name: MetricNormalizer.humanReadableName(for: identifier.rawValue),\n                    identifier: identifier.rawValue,\n                    value: 0,\n                    unit: MetricNormalizer.normalizedUnit(for: HKObjectType.quantityType(forIdentifier: identifier)!),\n                    timestamp: Date(),\n                    category: MetricNormalizer.categorizeMetric(identifier)\n                )\n            }\n            \n            DispatchQueue.main.async {\n                self.availableMetrics = metrics\n                self.isLoading = false\n            }\n        } catch {\n            DispatchQueue.main.async {\n                self.error = error\n                self.isLoading = false\n            }\n        }\n    }\n    \n    func isSelected(_ metric: HealthMetric) -> Bool {\n        return configService.isMetricSelected(metric.identifier)\n    }\n    \n    func toggleMetric(_ metric: HealthMetric) {\n        if isSelected(metric) {\n            configService.deselectMetric(metric.identifier)\n        } else {\n            configService.selectMetric(metric.identifier)\n        }\n        objectWillChange.send()\n    }\n    \n    func triggerSync() {\n        // Will be implemented in SyncEngine task\n    }\n}\n```",
        "testStrategy": "Create unit tests to verify:\n1. ConfigService correctly saves and loads user settings\n2. Metric selection/deselection works properly\n3. Settings persistence across app restarts\n\nCreate integration tests to verify the connection between MetricsSelectionViewModel and ConfigService. Test edge cases like selecting all metrics, deselecting all metrics, and handling large numbers of metrics.",
        "priority": "high",
        "dependencies": [
          2,
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Implement SyncTarget Protocol and Supabase Integration",
        "description": "Create the SyncTarget protocol and implement the SupabaseTarget as the first sync destination.",
        "details": "Define the SyncTarget protocol as an abstraction for all sync destinations. Implement the SupabaseTarget as the first concrete implementation.\n\n1. Create SyncTarget protocol:\n```swift\nprotocol SyncTarget {\n    var id: UUID { get }\n    var name: String { get }\n    var type: SyncDestinationType { get }\n    var isEnabled: Bool { get set }\n    var config: [String: String] { get set }\n    \n    func sync(metrics: [HealthMetric]) async throws -> SyncResult\n    func validate() -> Bool\n}\n\nenum SyncDestinationType: String, Codable, CaseIterable {\n    case supabase\n    case googleSheets\n    case zapier\n    case customAPI\n}\n\nstruct SyncResult: Identifiable {\n    let id = UUID()\n    let timestamp: Date\n    let success: Bool\n    let destination: SyncDestinationType\n    let metricsCount: Int\n    let errorMessage: String?\n    let responseCode: Int?\n    let responseBody: String?\n}\n```\n\n2. Implement SyncDestination model for persistence:\n```swift\nstruct SyncDestination: Identifiable, Codable {\n    let id: UUID\n    let type: SyncDestinationType\n    var name: String\n    var isEnabled: Bool\n    var config: [String: String]\n    \n    init(id: UUID = UUID(), type: SyncDestinationType, name: String, isEnabled: Bool = true, config: [String: String] = [:]) {\n        self.id = id\n        self.type = type\n        self.name = name\n        self.isEnabled = isEnabled\n        self.config = config\n    }\n}\n```\n\n3. Implement SupabaseTarget:\n```swift\nclass SupabaseTarget: SyncTarget {\n    let id: UUID\n    let name: String\n    let type: SyncDestinationType = .supabase\n    var isEnabled: Bool\n    var config: [String: String]\n    \n    // Required config keys\n    private let urlKey = \"url\"\n    private let apiKeyKey = \"apiKey\"\n    private let tableNameKey = \"tableName\"\n    \n    init(destination: SyncDestination) {\n        self.id = destination.id\n        self.name = destination.name\n        self.isEnabled = destination.isEnabled\n        self.config = destination.config\n    }\n    \n    func validate() -> Bool {\n        guard let url = config[urlKey], !url.isEmpty,\n              let apiKey = config[apiKeyKey], !apiKey.isEmpty,\n              let tableName = config[tableNameKey], !tableName.isEmpty else {\n            return false\n        }\n        \n        // Validate URL format\n        guard URL(string: url) != nil else {\n            return false\n        }\n        \n        return true\n    }\n    \n    func sync(metrics: [HealthMetric]) async throws -> SyncResult {\n        guard validate() else {\n            return SyncResult(\n                timestamp: Date(),\n                success: false,\n                destination: type,\n                metricsCount: metrics.count,\n                errorMessage: \"Invalid configuration\",\n                responseCode: nil,\n                responseBody: nil\n            )\n        }\n        \n        guard let url = URL(string: \"\\(config[urlKey]!)/rest/v1/\\(config[tableNameKey]!)\") else {\n            throw SyncError.invalidURL\n        }\n        \n        var request = URLRequest(url: url)\n        request.httpMethod = \"POST\"\n        request.addValue(\"application/json\", forHTTPHeaderField: \"Content-Type\")\n        request.addValue(config[apiKeyKey]!, forHTTPHeaderField: \"apikey\")\n        request.addValue(\"Bearer \\(config[apiKeyKey]!)\", forHTTPHeaderField: \"Authorization\")\n        \n        // Convert metrics to JSON\n        let encoder = JSONEncoder()\n        encoder.dateEncodingStrategy = .iso8601\n        let jsonData = try encoder.encode(metrics)\n        request.httpBody = jsonData\n        \n        // Perform request\n        let (data, response) = try await URLSession.shared.data(for: request)\n        \n        guard let httpResponse = response as? HTTPURLResponse else {\n            throw SyncError.invalidResponse\n        }\n        \n        let success = (200...299).contains(httpResponse.statusCode)\n        let responseBody = String(data: data, encoding: .utf8)\n        \n        return SyncResult(\n            timestamp: Date(),\n            success: success,\n            destination: type,\n            metricsCount: metrics.count,\n            errorMessage: success ? nil : \"HTTP Error: \\(httpResponse.statusCode)\",\n            responseCode: httpResponse.statusCode,\n            responseBody: responseBody\n        )\n    }\n}\n\nenum SyncError: Error {\n    case invalidURL\n    case invalidResponse\n    case configurationError\n}\n```\n\n4. Create SyncDestinationManager to handle destination persistence:\n```swift\nclass SyncDestinationManager {\n    static let shared = SyncDestinationManager()\n    \n    private let userDefaults = UserDefaults.standard\n    private let destinationsKey = \"healthsync.syncDestinations\"\n    \n    private(set) var destinations: [SyncDestination] {\n        get {\n            if let data = userDefaults.data(forKey: destinationsKey),\n               let destinations = try? JSONDecoder().decode([SyncDestination].self, from: data) {\n                return destinations\n            }\n            return []\n        }\n        set {\n            if let data = try? JSONEncoder().encode(newValue) {\n                userDefaults.set(data, forKey: destinationsKey)\n            }\n        }\n    }\n    \n    func addDestination(_ destination: SyncDestination) {\n        var updated = destinations\n        updated.append(destination)\n        destinations = updated\n    }\n    \n    func updateDestination(_ destination: SyncDestination) {\n        var updated = destinations\n        if let index = updated.firstIndex(where: { $0.id == destination.id }) {\n            updated[index] = destination\n            destinations = updated\n        }\n    }\n    \n    func removeDestination(id: UUID) {\n        var updated = destinations\n        updated.removeAll { $0.id == id }\n        destinations = updated\n    }\n    \n    func createSyncTarget(from destination: SyncDestination) -> SyncTarget? {\n        switch destination.type {\n        case .supabase:\n            return SupabaseTarget(destination: destination)\n        // Other cases will be implemented in subsequent tasks\n        default:\n            return nil\n        }\n    }\n}\n```",
        "testStrategy": "Create unit tests to verify:\n1. SyncTarget protocol implementation correctness\n2. SupabaseTarget validation logic\n3. SyncDestinationManager persistence\n\nCreate integration tests with mock HTTP responses to test:\n1. Successful Supabase sync\n2. Error handling for invalid configurations\n3. Error handling for network failures\n\nUse URLProtocol subclass for mocking network requests in tests.",
        "priority": "high",
        "dependencies": [
          2,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Implement SyncEngine and Manual Sync Functionality",
        "description": "Create the SyncEngine to coordinate data fetching from HealthKit and routing to active sync targets.",
        "details": "Implement the SyncEngine to handle the core sync functionality, including fetching data from HealthKit and routing it to enabled sync targets.\n\n1. Create the SyncEngine class:\n```swift\nclass SyncEngine {\n    static let shared = SyncEngine()\n    \n    private let healthKitManager = HealthKitManager.shared\n    private let configService = ConfigService.shared\n    private let destinationManager = SyncDestinationManager.shared\n    private let logger = Logger.shared\n    \n    @Published var isSyncing = false\n    \n    func sync() async -> [SyncResult] {\n        guard !isSyncing else { return [] }\n        \n        DispatchQueue.main.async {\n            self.isSyncing = true\n        }\n        \n        defer {\n            DispatchQueue.main.async {\n                self.isSyncing = false\n            }\n        }\n        \n        // Get selected metric identifiers\n        let selectedIdentifiers = configService.settings.selectedMetricIdentifiers\n        guard !selectedIdentifiers.isEmpty else {\n            return []\n        }\n        \n        // Get enabled destinations\n        let enabledDestinations = destinationManager.destinations.filter { $0.isEnabled }\n        guard !enabledDestinations.isEmpty else {\n            return []\n        }\n        \n        // Create sync targets from destinations\n        let syncTargets = enabledDestinations.compactMap { destinationManager.createSyncTarget(from: $0) }\n        \n        var results: [SyncResult] = []\n        \n        do {\n            // Fetch health data for selected metrics\n            var allMetrics: [HealthMetric] = []\n            \n            for identifier in selectedIdentifiers {\n                guard let typeIdentifier = HKQuantityTypeIdentifier(rawValue: identifier) else { continue }\n                \n                // Get data from the last 24 hours\n                let endDate = Date()\n                let startDate = Calendar.current.date(byAdding: .day, value: -1, to: endDate)!\n                \n                let samples = try await healthKitManager.fetchSamples(\n                    for: typeIdentifier,\n                    startDate: startDate,\n                    endDate: endDate\n                )\n                \n                // Convert samples to HealthMetric objects\n                let metrics = samples.compactMap { sample in\n                    guard let quantitySample = sample as? HKQuantitySample else { return nil }\n                    return MetricNormalizer.normalizeQuantitySample(quantitySample)\n                }\n                \n                allMetrics.append(contentsOf: metrics)\n            }\n            \n            // Sync to each target\n            for target in syncTargets {\n                do {\n                    let result = try await target.sync(metrics: allMetrics)\n                    results.append(result)\n                    logger.logSync(result: result)\n                } catch {\n                    let errorResult = SyncResult(\n                        timestamp: Date(),\n                        success: false,\n                        destination: target.type,\n                        metricsCount: allMetrics.count,\n                        errorMessage: error.localizedDescription,\n                        responseCode: nil,\n                        responseBody: nil\n                    )\n                    results.append(errorResult)\n                    logger.logSync(result: errorResult)\n                }\n            }\n            \n            // Update last sync date\n            configService.updateLastSyncDate()\n            \n            return results\n        } catch {\n            let errorResult = SyncResult(\n                timestamp: Date(),\n                success: false,\n                destination: .supabase, // Default type for general errors\n                metricsCount: 0,\n                errorMessage: \"Failed to fetch health data: \\(error.localizedDescription)\",\n                responseCode: nil,\n                responseBody: nil\n            )\n            results.append(errorResult)\n            logger.logSync(result: errorResult)\n            return results\n        }\n    }\n}\n```\n\n2. Update MetricsSelectionViewModel to use SyncEngine:\n```swift\nfunc triggerSync() {\n    Task {\n        let results = await SyncEngine.shared.sync()\n        DispatchQueue.main.async {\n            // Update UI with sync results if needed\n        }\n    }\n}\n```\n\n3. Create a SyncButton component for reuse:\n```swift\nstruct SyncButton: View {\n    @ObservedObject private var syncEngine = SyncEngine.shared\n    var action: () -> Void\n    \n    var body: some View {\n        Button(action: action) {\n            HStack {\n                Text(\"Sync Now\")\n                if syncEngine.isSyncing {\n                    ProgressView()\n                        .progressViewStyle(CircularProgressViewStyle())\n                }\n            }\n        }\n        .disabled(syncEngine.isSyncing)\n    }\n}\n```\n\n4. Add a manual sync button to the main UI:\n```swift\nToolbar {\n    SyncButton {\n        Task {\n            await SyncEngine.shared.sync()\n        }\n    }\n}\n```",
        "testStrategy": "Create unit tests to verify:\n1. SyncEngine correctly fetches data from HealthKit\n2. SyncEngine properly routes data to enabled targets\n3. Error handling for various failure scenarios\n\nCreate integration tests to verify:\n1. End-to-end sync flow with mock data\n2. Proper handling of multiple sync targets\n3. UI state updates during sync process\n\nTest performance with large datasets to ensure the app remains responsive during sync operations.",
        "priority": "high",
        "dependencies": [
          1,
          2,
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Implement Logger and Logs Panel",
        "description": "Create the Logger service to track sync operations and implement the Logs panel UI to display sync history.",
        "details": "Implement the Logger service to track sync operations and create the Logs panel UI to display sync history.\n\n1. Create the Logger class:\n```swift\nclass Logger {\n    static let shared = Logger()\n    \n    private let userDefaults = UserDefaults.standard\n    private let logsKey = \"healthsync.syncLogs\"\n    private let maxLogEntries = 100\n    \n    @Published private(set) var logs: [SyncResult] = []\n    \n    init() {\n        loadLogs()\n    }\n    \n    private func loadLogs() {\n        if let data = userDefaults.data(forKey: logsKey),\n           let logs = try? JSONDecoder().decode([SyncResult].self, from: data) {\n            self.logs = logs\n        }\n    }\n    \n    private func saveLogs() {\n        if let data = try? JSONEncoder().encode(logs) {\n            userDefaults.set(data, forKey: logsKey)\n        }\n    }\n    \n    func logSync(result: SyncResult) {\n        DispatchQueue.main.async {\n            var updatedLogs = self.logs\n            updatedLogs.insert(result, at: 0)\n            \n            // Limit the number of logs\n            if updatedLogs.count > self.maxLogEntries {\n                updatedLogs = Array(updatedLogs.prefix(self.maxLogEntries))\n            }\n            \n            self.logs = updatedLogs\n            self.saveLogs()\n        }\n    }\n    \n    func clearLogs() {\n        logs = []\n        saveLogs()\n    }\n}\n```\n\n2. Implement the LogsView:\n```swift\nstruct LogsView: View {\n    @ObservedObject private var logger = Logger.shared\n    @State private var selectedLog: SyncResult?\n    @State private var showingDetail = false\n    \n    var body: some View {\n        NavigationView {\n            List {\n                if logger.logs.isEmpty {\n                    Text(\"No sync logs yet\")\n                        .foregroundColor(.secondary)\n                        .frame(maxWidth: .infinity, alignment: .center)\n                        .padding()\n                } else {\n                    ForEach(logger.logs) { log in\n                        LogRow(log: log)\n                            .onTapGesture {\n                                selectedLog = log\n                                showingDetail = true\n                            }\n                    }\n                }\n            }\n            .navigationTitle(\"Sync Logs\")\n            .toolbar {\n                Button(action: {\n                    // Show confirmation dialog\n                    // Then call logger.clearLogs()\n                }) {\n                    Label(\"Clear\", systemImage: \"trash\")\n                }\n            }\n            .sheet(isPresented: $showingDetail) {\n                if let log = selectedLog {\n                    LogDetailView(log: log)\n                }\n            }\n        }\n    }\n}\n\nstruct LogRow: View {\n    let log: SyncResult\n    \n    var body: some View {\n        HStack {\n            Image(systemName: log.success ? \"checkmark.circle.fill\" : \"xmark.circle.fill\")\n                .foregroundColor(log.success ? .green : .red)\n            \n            VStack(alignment: .leading) {\n                Text(log.destination.rawValue.capitalized)\n                    .font(.headline)\n                \n                Text(\"\\(log.metricsCount) metrics â€¢ \\(formattedDate)\")\n                    .font(.caption)\n                    .foregroundColor(.secondary)\n                \n                if let error = log.errorMessage {\n                    Text(error)\n                        .font(.caption)\n                        .foregroundColor(.red)\n                        .lineLimit(1)\n                }\n            }\n            \n            Spacer()\n            \n            Image(systemName: \"chevron.right\")\n                .foregroundColor(.secondary)\n        }\n        .padding(.vertical, 4)\n    }\n    \n    private var formattedDate: String {\n        let formatter = DateFormatter()\n        formatter.dateStyle = .short\n        formatter.timeStyle = .short\n        return formatter.string(from: log.timestamp)\n    }\n}\n\nstruct LogDetailView: View {\n    let log: SyncResult\n    \n    var body: some View {\n        NavigationView {\n            Form {\n                Section(header: Text(\"General\")) {\n                    LabeledContent(\"Status\", value: log.success ? \"Success\" : \"Failed\")\n                    LabeledContent(\"Destination\", value: log.destination.rawValue.capitalized)\n                    LabeledContent(\"Timestamp\", value: formattedDate)\n                    LabeledContent(\"Metrics Count\", value: \"\\(log.metricsCount)\")\n                }\n                \n                if let code = log.responseCode {\n                    Section(header: Text(\"Response\")) {\n                        LabeledContent(\"Status Code\", value: \"\\(code)\")\n                    }\n                }\n                \n                if let error = log.errorMessage {\n                    Section(header: Text(\"Error\")) {\n                        Text(error)\n                            .foregroundColor(.red)\n                    }\n                }\n                \n                if let body = log.responseBody {\n                    Section(header: Text(\"Response Body\")) {\n                        Text(body)\n                            .font(.system(.body, design: .monospaced))\n                    }\n                }\n            }\n            .navigationTitle(\"Sync Details\")\n            .navigationBarTitleDisplayMode(.inline)\n        }\n    }\n    \n    private var formattedDate: String {\n        let formatter = DateFormatter()\n        formatter.dateStyle = .medium\n        formatter.timeStyle = .medium\n        return formatter.string(from: log.timestamp)\n    }\n}\n```",
        "testStrategy": "Create unit tests to verify:\n1. Logger correctly stores and retrieves logs\n2. Log limit enforcement\n3. Proper serialization/deserialization of logs\n\nCreate UI tests to verify:\n1. Logs display correctly in the UI\n2. Log detail view shows all relevant information\n3. Clear logs functionality works as expected\n\nTest with various log types (success, error) and edge cases (empty logs, maximum logs).",
        "priority": "medium",
        "dependencies": [
          3,
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Implement Google Sheets Integration",
        "description": "Create the GoogleSheetsTarget to sync health data to Google Sheets via App Script Webhook.",
        "details": "Implement the GoogleSheetsTarget to sync health data to Google Sheets using the App Script Webhook method as specified in the PRD.\n\n1. Create GoogleSheetsTarget class:\n```swift\nclass GoogleSheetsTarget: SyncTarget {\n    let id: UUID\n    let name: String\n    let type: SyncDestinationType = .googleSheets\n    var isEnabled: Bool\n    var config: [String: String]\n    \n    // Required config keys\n    private let webhookUrlKey = \"webhookUrl\"\n    private let secretKey = \"secret\"\n    \n    init(destination: SyncDestination) {\n        self.id = destination.id\n        self.name = destination.name\n        self.isEnabled = destination.isEnabled\n        self.config = destination.config\n    }\n    \n    func validate() -> Bool {\n        guard let webhookUrl = config[webhookUrlKey], !webhookUrl.isEmpty else {\n            return false\n        }\n        \n        // Validate URL format\n        guard URL(string: webhookUrl) != nil else {\n            return false\n        }\n        \n        return true\n    }\n    \n    func sync(metrics: [HealthMetric]) async throws -> SyncResult {\n        guard validate() else {\n            return SyncResult(\n                timestamp: Date(),\n                success: false,\n                destination: type,\n                metricsCount: metrics.count,\n                errorMessage: \"Invalid configuration\",\n                responseCode: nil,\n                responseBody: nil\n            )\n        }\n        \n        guard let url = URL(string: config[webhookUrlKey]!) else {\n            throw SyncError.invalidURL\n        }\n        \n        var request = URLRequest(url: url)\n        request.httpMethod = \"POST\"\n        request.addValue(\"application/json\", forHTTPHeaderField: \"Content-Type\")\n        \n        // Prepare data for Google Sheets format\n        // Convert metrics to a format suitable for Google Sheets\n        struct SheetPayload: Codable {\n            let metrics: [[String]]\n            let secret: String?\n        }\n        \n        // Create header row\n        let headers = [\"name\", \"identifier\", \"value\", \"unit\", \"timestamp\", \"source\", \"category\"]\n        \n        // Create data rows\n        var rows: [[String]] = [headers]\n        for metric in metrics {\n            let row = [\n                metric.name,\n                metric.identifier,\n                String(metric.value),\n                metric.unit,\n                ISO8601DateFormatter().string(from: metric.timestamp),\n                metric.source ?? \"\",\n                metric.category.rawValue\n            ]\n            rows.append(row)\n        }\n        \n        // Create payload\n        let payload = SheetPayload(\n            metrics: rows,\n            secret: config[secretKey]\n        )\n        \n        // Convert to JSON\n        let encoder = JSONEncoder()\n        let jsonData = try encoder.encode(payload)\n        request.httpBody = jsonData\n        \n        // Perform request\n        let (data, response) = try await URLSession.shared.data(for: request)\n        \n        guard let httpResponse = response as? HTTPURLResponse else {\n            throw SyncError.invalidResponse\n        }\n        \n        let success = (200...299).contains(httpResponse.statusCode)\n        let responseBody = String(data: data, encoding: .utf8)\n        \n        return SyncResult(\n            timestamp: Date(),\n            success: success,\n            destination: type,\n            metricsCount: metrics.count,\n            errorMessage: success ? nil : \"HTTP Error: \\(httpResponse.statusCode)\",\n            responseCode: httpResponse.statusCode,\n            responseBody: responseBody\n        )\n    }\n}\n```\n\n2. Update SyncDestinationManager to support GoogleSheetsTarget:\n```swift\nfunc createSyncTarget(from destination: SyncDestination) -> SyncTarget? {\n    switch destination.type {\n    case .supabase:\n        return SupabaseTarget(destination: destination)\n    case .googleSheets:\n        return GoogleSheetsTarget(destination: destination)\n    // Other cases will be implemented in subsequent tasks\n    default:\n        return nil\n    }\n}\n```\n\n3. Create GoogleSheetsConfigView for setup:\n```swift\nstruct GoogleSheetsConfigView: View {\n    @Binding var destination: SyncDestination\n    @State private var webhookUrl: String\n    @State private var secret: String\n    @Environment(\\.presentationMode) var presentationMode\n    \n    init(destination: Binding<SyncDestination>) {\n        self._destination = destination\n        self._webhookUrl = State(initialValue: destination.wrappedValue.config[\"webhookUrl\"] ?? \"\")\n        self._secret = State(initialValue: destination.wrappedValue.config[\"secret\"] ?? \"\")\n    }\n    \n    var body: some View {\n        Form {\n            Section(header: Text(\"Google Sheets Configuration\")) {\n                TextField(\"Webhook URL\", text: $webhookUrl)\n                    .autocapitalization(.none)\n                    .disableAutocorrection(true)\n                \n                SecureField(\"Secret Key (Optional)\", text: $secret)\n            }\n            \n            Section(header: Text(\"Setup Instructions\")) {\n                VStack(alignment: .leading, spacing: 10) {\n                    Text(\"1. Open your Google Sheet\")\n                    Text(\"2. Go to Extensions > Apps Script\")\n                    Text(\"3. Paste the provided script\")\n                    Text(\"4. Deploy as web app\")\n                    Text(\"5. Copy the web app URL\")\n                    Text(\"6. Paste the URL above\")\n                }\n                .font(.caption)\n            }\n            \n            Section {\n                Button(\"Save\") {\n                    var updatedConfig = destination.config\n                    updatedConfig[\"webhookUrl\"] = webhookUrl\n                    updatedConfig[\"secret\"] = secret\n                    \n                    var updatedDestination = destination\n                    updatedDestination.config = updatedConfig\n                    \n                    destination = updatedDestination\n                    presentationMode.wrappedValue.dismiss()\n                }\n                .disabled(webhookUrl.isEmpty)\n            }\n        }\n        .navigationTitle(\"Google Sheets Setup\")\n    }\n}\n```\n\n4. Provide Google Apps Script code for users:\n```javascript\n// Google Apps Script for HealthSync\nfunction doPost(e) {\n  try {\n    // Parse the incoming JSON data\n    const data = JSON.parse(e.postData.contents);\n    \n    // Optional: Verify secret if provided\n    const secret = data.secret;\n    const expectedSecret = PropertiesService.getScriptProperties().getProperty('SECRET');\n    if (expectedSecret && secret !== expectedSecret) {\n      return ContentService.createTextOutput(JSON.stringify({\n        success: false,\n        error: 'Invalid secret'\n      })).setMimeType(ContentService.MimeType.JSON);\n    }\n    \n    // Get active spreadsheet and sheet\n    const ss = SpreadsheetApp.getActiveSpreadsheet();\n    const sheet = ss.getActiveSheet();\n    \n    // Clear existing data (optional)\n    // sheet.clear();\n    \n    // Append all rows\n    sheet.getRange(sheet.getLastRow() + 1, 1, data.metrics.length, data.metrics[0].length)\n      .setValues(data.metrics);\n    \n    return ContentService.createTextOutput(JSON.stringify({\n      success: true,\n      rowsAdded: data.metrics.length\n    })).setMimeType(ContentService.MimeType.JSON);\n  } catch (error) {\n    return ContentService.createTextOutput(JSON.stringify({\n      success: false,\n      error: error.toString()\n    })).setMimeType(ContentService.MimeType.JSON);\n  }\n}\n```",
        "testStrategy": "Create unit tests to verify:\n1. GoogleSheetsTarget validation logic\n2. Correct formatting of data for Google Sheets\n3. Proper handling of the webhook response\n\nCreate integration tests with mock HTTP responses to test:\n1. Successful Google Sheets sync\n2. Error handling for invalid configurations\n3. Error handling for network failures\n\nTest with various data sizes to ensure the app handles large datasets correctly.",
        "priority": "medium",
        "dependencies": [
          5,
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Implement Zapier Webhook Integration",
        "description": "Create the ZapierTarget to sync health data to Zapier via webhooks.",
        "details": "Implement the ZapierTarget to sync health data to Zapier using webhooks as specified in the PRD.\n\n1. Create ZapierTarget class:\n```swift\nclass ZapierTarget: SyncTarget {\n    let id: UUID\n    let name: String\n    let type: SyncDestinationType = .zapier\n    var isEnabled: Bool\n    var config: [String: String]\n    \n    // Required config keys\n    private let webhookUrlKey = \"webhookUrl\"\n    private let batchSizeKey = \"batchSize\"\n    \n    init(destination: SyncDestination) {\n        self.id = destination.id\n        self.name = destination.name\n        self.isEnabled = destination.isEnabled\n        self.config = destination.config\n        \n        // Set default batch size if not specified\n        if config[batchSizeKey] == nil {\n            config[batchSizeKey] = \"10\"\n        }\n    }\n    \n    func validate() -> Bool {\n        guard let webhookUrl = config[webhookUrlKey], !webhookUrl.isEmpty else {\n            return false\n        }\n        \n        // Validate URL format\n        guard URL(string: webhookUrl) != nil else {\n            return false\n        }\n        \n        return true\n    }\n    \n    func sync(metrics: [HealthMetric]) async throws -> SyncResult {\n        guard validate() else {\n            return SyncResult(\n                timestamp: Date(),\n                success: false,\n                destination: type,\n                metricsCount: metrics.count,\n                errorMessage: \"Invalid configuration\",\n                responseCode: nil,\n                responseBody: nil\n            )\n        }\n        \n        guard let url = URL(string: config[webhookUrlKey]!) else {\n            throw SyncError.invalidURL\n        }\n        \n        // Get batch size (default to 10 if not specified or invalid)\n        let batchSize = Int(config[batchSizeKey] ?? \"10\") ?? 10\n        \n        // Split metrics into batches to avoid overwhelming Zapier\n        let batches = stride(from: 0, to: metrics.count, by: batchSize).map {\n            Array(metrics[($0)..<min($0 + batchSize, metrics.count)])\n        }\n        \n        var successCount = 0\n        var failureCount = 0\n        var lastResponseCode: Int? = nil\n        var lastResponseBody: String? = nil\n        var lastErrorMessage: String? = nil\n        \n        // Process each batch\n        for batch in batches {\n            var request = URLRequest(url: url)\n            request.httpMethod = \"POST\"\n            request.addValue(\"application/json\", forHTTPHeaderField: \"Content-Type\")\n            \n            // Convert metrics to JSON\n            let encoder = JSONEncoder()\n            encoder.dateEncodingStrategy = .iso8601\n            let jsonData = try encoder.encode(batch)\n            request.httpBody = jsonData\n            \n            do {\n                // Perform request\n                let (data, response) = try await URLSession.shared.data(for: request)\n                \n                guard let httpResponse = response as? HTTPURLResponse else {\n                    throw SyncError.invalidResponse\n                }\n                \n                lastResponseCode = httpResponse.statusCode\n                lastResponseBody = String(data: data, encoding: .utf8)\n                \n                if (200...299).contains(httpResponse.statusCode) {\n                    successCount += batch.count\n                } else {\n                    failureCount += batch.count\n                    lastErrorMessage = \"HTTP Error: \\(httpResponse.statusCode)\"\n                }\n            } catch {\n                failureCount += batch.count\n                lastErrorMessage = error.localizedDescription\n            }\n            \n            // Add a small delay between batches to avoid rate limiting\n            if batches.count > 1 {\n                try await Task.sleep(nanoseconds: 500_000_000) // 0.5 seconds\n            }\n        }\n        \n        let success = failureCount == 0 && successCount > 0\n        \n        return SyncResult(\n            timestamp: Date(),\n            success: success,\n            destination: type,\n            metricsCount: metrics.count,\n            errorMessage: lastErrorMessage,\n            responseCode: lastResponseCode,\n            responseBody: lastResponseBody\n        )\n    }\n}\n```\n\n2. Update SyncDestinationManager to support ZapierTarget:\n```swift\nfunc createSyncTarget(from destination: SyncDestination) -> SyncTarget? {\n    switch destination.type {\n    case .supabase:\n        return SupabaseTarget(destination: destination)\n    case .googleSheets:\n        return GoogleSheetsTarget(destination: destination)\n    case .zapier:\n        return ZapierTarget(destination: destination)\n    // Other cases will be implemented in subsequent tasks\n    default:\n        return nil\n    }\n}\n```\n\n3. Create ZapierConfigView for setup:\n```swift\nstruct ZapierConfigView: View {\n    @Binding var destination: SyncDestination\n    @State private var webhookUrl: String\n    @State private var batchSize: String\n    @Environment(\\.presentationMode) var presentationMode\n    \n    init(destination: Binding<SyncDestination>) {\n        self._destination = destination\n        self._webhookUrl = State(initialValue: destination.wrappedValue.config[\"webhookUrl\"] ?? \"\")\n        self._batchSize = State(initialValue: destination.wrappedValue.config[\"batchSize\"] ?? \"10\")\n    }\n    \n    var body: some View {\n        Form {\n            Section(header: Text(\"Zapier Webhook Configuration\")) {\n                TextField(\"Webhook URL\", text: $webhookUrl)\n                    .autocapitalization(.none)\n                    .disableAutocorrection(true)\n                \n                TextField(\"Batch Size\", text: $batchSize)\n                    .keyboardType(.numberPad)\n            }\n            \n            Section(header: Text(\"Setup Instructions\")) {\n                VStack(alignment: .leading, spacing: 10) {\n                    Text(\"1. Create a new Zap in Zapier\")\n                    Text(\"2. Select 'Webhooks by Zapier' as the trigger\")\n                    Text(\"3. Choose 'Catch Hook' as the event\")\n                    Text(\"4. Copy the webhook URL\")\n                    Text(\"5. Paste the URL above\")\n                    Text(\"6. Configure your Zap actions\")\n                }\n                .font(.caption)\n            }\n            \n            Section {\n                Button(\"Save\") {\n                    var updatedConfig = destination.config\n                    updatedConfig[\"webhookUrl\"] = webhookUrl\n                    updatedConfig[\"batchSize\"] = batchSize\n                    \n                    var updatedDestination = destination\n                    updatedDestination.config = updatedConfig\n                    \n                    destination = updatedDestination\n                    presentationMode.wrappedValue.dismiss()\n                }\n                .disabled(webhookUrl.isEmpty)\n            }\n        }\n        .navigationTitle(\"Zapier Setup\")\n    }\n}\n```\n\n4. Add Zapier webhook format documentation for users:\n```\nZapier Webhook Format\n\nYour Zap will receive health metrics in this JSON format:\n\n[\n  {\n    \"name\": \"Heart Rate\",\n    \"identifier\": \"HKQuantityTypeIdentifierHeartRate\",\n    \"value\": 72,\n    \"unit\": \"bpm\",\n    \"timestamp\": \"2023-01-01T12:00:00Z\",\n    \"source\": \"Apple Watch\",\n    \"category\": \"vitals\"\n  },\n  ...\n]\n\nEach webhook request will contain up to [batch size] metrics.\nConfigure your Zap actions to process this data as needed.\n```",
        "testStrategy": "Create unit tests to verify:\n1. ZapierTarget validation logic\n2. Batch processing functionality\n3. Proper handling of the webhook response\n\nCreate integration tests with mock HTTP responses to test:\n1. Successful Zapier sync with different batch sizes\n2. Error handling for invalid configurations\n3. Error handling for network failures\n\nTest with various data sizes to ensure batching works correctly and rate limits are respected.",
        "priority": "medium",
        "dependencies": [
          5,
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Implement Custom API Integration with Templating",
        "description": "Create the CustomAPITarget with JSON templating support for maximum flexibility.",
        "details": "Implement the CustomAPITarget with templating support to allow users to define custom JSON payloads for their APIs.\n\n1. Create SyncTemplateEngine for template processing:\n```swift\nclass SyncTemplateEngine {\n    static func processTemplate(_ template: String, with metrics: [HealthMetric]) -> String? {\n        // Replace {{metrics}} with the JSON array of all metrics\n        if template.contains(\"{{metrics}}\") {\n            guard let metricsJson = try? JSONEncoder().encode(metrics),\n                  let metricsJsonString = String(data: metricsJson, encoding: .utf8) else {\n                return nil\n            }\n            \n            return template.replacingOccurrences(of: \"{{metrics}}\", with: metricsJsonString)\n        }\n        \n        // Replace {{count}} with the number of metrics\n        if template.contains(\"{{count}}\") {\n            return template.replacingOccurrences(of: \"{{count}}\", with: String(metrics.count))\n        }\n        \n        // Replace {{timestamp}} with the current timestamp\n        if template.contains(\"{{timestamp}}\") {\n            let timestamp = ISO8601DateFormatter().string(from: Date())\n            return template.replacingOccurrences(of: \"{{timestamp}}\", with: timestamp)\n        }\n        \n        // If no replacements needed, return the template as is\n        return template\n    }\n}\n```\n\n2. Create CustomAPITarget class:\n```swift\nclass CustomAPITarget: SyncTarget {\n    let id: UUID\n    let name: String\n    let type: SyncDestinationType = .customAPI\n    var isEnabled: Bool\n    var config: [String: String]\n    \n    // Required config keys\n    private let urlKey = \"url\"\n    private let methodKey = \"method\"\n    private let headersKey = \"headers\"\n    private let bodyTemplateKey = \"bodyTemplate\"\n    \n    init(destination: SyncDestination) {\n        self.id = destination.id\n        self.name = destination.name\n        self.isEnabled = destination.isEnabled\n        self.config = destination.config\n        \n        // Set default method if not specified\n        if config[methodKey] == nil {\n            config[methodKey] = \"POST\"\n        }\n    }\n    \n    func validate() -> Bool {\n        guard let url = config[urlKey], !url.isEmpty,\n              let method = config[methodKey], !method.isEmpty else {\n            return false\n        }\n        \n        // Validate URL format\n        guard URL(string: url) != nil else {\n            return false\n        }\n        \n        // Validate HTTP method\n        let validMethods = [\"GET\", \"POST\", \"PUT\", \"PATCH\", \"DELETE\"]\n        guard validMethods.contains(method.uppercased()) else {\n            return false\n        }\n        \n        return true\n    }\n    \n    func sync(metrics: [HealthMetric]) async throws -> SyncResult {\n        guard validate() else {\n            return SyncResult(\n                timestamp: Date(),\n                success: false,\n                destination: type,\n                metricsCount: metrics.count,\n                errorMessage: \"Invalid configuration\",\n                responseCode: nil,\n                responseBody: nil\n            )\n        }\n        \n        guard let url = URL(string: config[urlKey]!) else {\n            throw SyncError.invalidURL\n        }\n        \n        var request = URLRequest(url: url)\n        request.httpMethod = config[methodKey]!.uppercased()\n        \n        // Add headers if specified\n        if let headersString = config[headersKey], !headersString.isEmpty {\n            do {\n                if let headersData = headersString.data(using: .utf8),\n                   let headers = try JSONSerialization.jsonObject(with: headersData) as? [String: String] {\n                    for (key, value) in headers {\n                        request.addValue(value, forHTTPHeaderField: key)\n                    }\n                }\n            } catch {\n                return SyncResult(\n                    timestamp: Date(),\n                    success: false,\n                    destination: type,\n                    metricsCount: metrics.count,\n                    errorMessage: \"Invalid headers format: \\(error.localizedDescription)\",\n                    responseCode: nil,\n                    responseBody: nil\n                )\n            }\n        } else {\n            // Default content type if no headers specified\n            request.addValue(\"application/json\", forHTTPHeaderField: \"Content-Type\")\n        }\n        \n        // Process body template if specified\n        if let bodyTemplate = config[bodyTemplateKey], !bodyTemplate.isEmpty {\n            if let processedTemplate = SyncTemplateEngine.processTemplate(bodyTemplate, with: metrics),\n               let bodyData = processedTemplate.data(using: .utf8) {\n                request.httpBody = bodyData\n            } else {\n                return SyncResult(\n                    timestamp: Date(),\n                    success: false,\n                    destination: type,\n                    metricsCount: metrics.count,\n                    errorMessage: \"Failed to process template\",\n                    responseCode: nil,\n                    responseBody: nil\n                )\n            }\n        } else {\n            // Default to sending metrics array if no template\n            let encoder = JSONEncoder()\n            encoder.dateEncodingStrategy = .iso8601\n            request.httpBody = try encoder.encode(metrics)\n        }\n        \n        // Perform request\n        let (data, response) = try await URLSession.shared.data(for: request)\n        \n        guard let httpResponse = response as? HTTPURLResponse else {\n            throw SyncError.invalidResponse\n        }\n        \n        let success = (200...299).contains(httpResponse.statusCode)\n        let responseBody = String(data: data, encoding: .utf8)\n        \n        return SyncResult(\n            timestamp: Date(),\n            success: success,\n            destination: type,\n            metricsCount: metrics.count,\n            errorMessage: success ? nil : \"HTTP Error: \\(httpResponse.statusCode)\",\n            responseCode: httpResponse.statusCode,\n            responseBody: responseBody\n        )\n    }\n}\n```\n\n3. Update SyncDestinationManager to support CustomAPITarget:\n```swift\nfunc createSyncTarget(from destination: SyncDestination) -> SyncTarget? {\n    switch destination.type {\n    case .supabase:\n        return SupabaseTarget(destination: destination)\n    case .googleSheets:\n        return GoogleSheetsTarget(destination: destination)\n    case .zapier:\n        return ZapierTarget(destination: destination)\n    case .customAPI:\n        return CustomAPITarget(destination: destination)\n    }\n}\n```\n\n4. Create CustomAPIConfigView for setup:\n```swift\nstruct CustomAPIConfigView: View {\n    @Binding var destination: SyncDestination\n    @State private var url: String\n    @State private var method: String\n    @State private var headers: String\n    @State private var bodyTemplate: String\n    @Environment(\\.presentationMode) var presentationMode\n    \n    private let methods = [\"GET\", \"POST\", \"PUT\", \"PATCH\", \"DELETE\"]\n    \n    init(destination: Binding<SyncDestination>) {\n        self._destination = destination\n        self._url = State(initialValue: destination.wrappedValue.config[\"url\"] ?? \"\")\n        self._method = State(initialValue: destination.wrappedValue.config[\"method\"] ?? \"POST\")\n        self._headers = State(initialValue: destination.wrappedValue.config[\"headers\"] ?? \"\")\n        self._bodyTemplate = State(initialValue: destination.wrappedValue.config[\"bodyTemplate\"] ?? \"\")\n    }\n    \n    var body: some View {\n        Form {\n            Section(header: Text(\"API Configuration\")) {\n                TextField(\"URL\", text: $url)\n                    .autocapitalization(.none)\n                    .disableAutocorrection(true)\n                \n                Picker(\"Method\", selection: $method) {\n                    ForEach(methods, id: \\.self) { method in\n                        Text(method).tag(method)\n                    }\n                }\n                .pickerStyle(SegmentedPickerStyle())\n            }\n            \n            Section(header: Text(\"Headers (JSON)\")) {\n                TextEditor(text: $headers)\n                    .frame(minHeight: 100)\n                    .font(.system(.body, design: .monospaced))\n                \n                Text(\"Example: {\\\"Content-Type\\\": \\\"application/json\\\", \\\"Authorization\\\": \\\"Bearer token\\\"}\")\n                    .font(.caption)\n                    .foregroundColor(.secondary)\n            }\n            \n            Section(header: Text(\"Body Template (Optional)\")) {\n                TextEditor(text: $bodyTemplate)\n                    .frame(minHeight: 150)\n                    .font(.system(.body, design: .monospaced))\n                \n                Text(\"Use {{metrics}} to insert all metrics as a JSON array\")\n                    .font(.caption)\n                    .foregroundColor(.secondary)\n                \n                Text(\"Example: {\\\"data\\\": {{metrics}}, \\\"timestamp\\\": \\\"{{timestamp}}\\\", \\\"count\\\": {{count}}}\")\n                    .font(.caption)\n                    .foregroundColor(.secondary)\n            }\n            \n            Section {\n                Button(\"Save\") {\n                    var updatedConfig = destination.config\n                    updatedConfig[\"url\"] = url\n                    updatedConfig[\"method\"] = method\n                    updatedConfig[\"headers\"] = headers\n                    updatedConfig[\"bodyTemplate\"] = bodyTemplate\n                    \n                    var updatedDestination = destination\n                    updatedDestination.config = updatedConfig\n                    \n                    destination = updatedDestination\n                    presentationMode.wrappedValue.dismiss()\n                }\n                .disabled(url.isEmpty)\n            }\n        }\n        .navigationTitle(\"Custom API Setup\")\n    }\n}\n```",
        "testStrategy": "Create unit tests to verify:\n1. SyncTemplateEngine correctly processes templates\n2. CustomAPITarget validation logic\n3. Proper handling of different HTTP methods\n4. Correct header and body processing\n\nCreate integration tests with mock HTTP responses to test:\n1. Successful API calls with different templates\n2. Error handling for invalid configurations\n3. Error handling for network failures\n\nTest with various template formats to ensure flexibility and robustness.",
        "priority": "medium",
        "dependencies": [
          5,
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Implement Sync Destination Management UI",
        "description": "Create the UI for managing sync destinations, including adding, editing, and removing destinations.",
        "details": "Implement the UI for managing sync destinations, allowing users to add, edit, and remove destinations.\n\n1. Create SyncDestinationsView:\n```swift\nstruct SyncDestinationsView: View {\n    @StateObject private var viewModel = SyncDestinationsViewModel()\n    @State private var showingAddSheet = false\n    @State private var editingDestination: SyncDestination?\n    \n    var body: some View {\n        NavigationView {\n            List {\n                if viewModel.destinations.isEmpty {\n                    Text(\"No sync destinations configured\")\n                        .foregroundColor(.secondary)\n                        .frame(maxWidth: .infinity, alignment: .center)\n                        .padding()\n                } else {\n                    ForEach(viewModel.destinations) { destination in\n                        DestinationRow(destination: destination)\n                            .onTapGesture {\n                                editingDestination = destination\n                            }\n                    }\n                    .onDelete { indexSet in\n                        viewModel.removeDestinations(at: indexSet)\n                    }\n                }\n            }\n            .navigationTitle(\"Sync Destinations\")\n            .toolbar {\n                Button(action: {\n                    showingAddSheet = true\n                }) {\n                    Label(\"Add\", systemImage: \"plus\")\n                }\n            }\n            .sheet(isPresented: $showingAddSheet) {\n                AddDestinationView { newDestination in\n                    viewModel.addDestination(newDestination)\n                    showingAddSheet = false\n                }\n            }\n            .sheet(item: $editingDestination) { destination in\n                EditDestinationView(destination: destination) { updatedDestination in\n                    viewModel.updateDestination(updatedDestination)\n                    editingDestination = nil\n                }\n            }\n        }\n    }\n}\n\nstruct DestinationRow: View {\n    let destination: SyncDestination\n    \n    var body: some View {\n        HStack {\n            VStack(alignment: .leading) {\n                Text(destination.name)\n                    .font(.headline)\n                \n                Text(destination.type.rawValue.capitalized)\n                    .font(.caption)\n                    .foregroundColor(.secondary)\n            }\n            \n            Spacer()\n            \n            if destination.isEnabled {\n                Image(systemName: \"checkmark.circle.fill\")\n                    .foregroundColor(.green)\n            } else {\n                Image(systemName: \"xmark.circle.fill\")\n                    .foregroundColor(.red)\n            }\n        }\n        .padding(.vertical, 4)\n    }\n}\n```\n\n2. Create SyncDestinationsViewModel:\n```swift\nclass SyncDestinationsViewModel: ObservableObject {\n    @Published var destinations: [SyncDestination] = []\n    \n    private let destinationManager = SyncDestinationManager.shared\n    \n    init() {\n        loadDestinations()\n    }\n    \n    func loadDestinations() {\n        destinations = destinationManager.destinations\n    }\n    \n    func addDestination(_ destination: SyncDestination) {\n        destinationManager.addDestination(destination)\n        loadDestinations()\n    }\n    \n    func updateDestination(_ destination: SyncDestination) {\n        destinationManager.updateDestination(destination)\n        loadDestinations()\n    }\n    \n    func removeDestinations(at indexSet: IndexSet) {\n        for index in indexSet {\n            let id = destinations[index].id\n            destinationManager.removeDestination(id: id)\n        }\n        loadDestinations()\n    }\n}\n```\n\n3. Create AddDestinationView:\n```swift\nstruct AddDestinationView: View {\n    @State private var name = \"\"\n    @State private var selectedType: SyncDestinationType = .supabase\n    @Environment(\\.presentationMode) var presentationMode\n    \n    let onAdd: (SyncDestination) -> Void\n    \n    var body: some View {\n        NavigationView {\n            Form {\n                Section(header: Text(\"Destination Details\")) {\n                    TextField(\"Name\", text: $name)\n                    \n                    Picker(\"Type\", selection: $selectedType) {\n                        ForEach(SyncDestinationType.allCases, id: \\.self) { type in\n                            Text(type.rawValue.capitalized).tag(type)\n                        }\n                    }\n                }\n                \n                Section {\n                    Button(\"Add\") {\n                        let newDestination = SyncDestination(\n                            type: selectedType,\n                            name: name.isEmpty ? \"\\(selectedType.rawValue.capitalized) Destination\" : name,\n                            isEnabled: true\n                        )\n                        onAdd(newDestination)\n                    }\n                    .disabled(name.isEmpty)\n                }\n            }\n            .navigationTitle(\"Add Destination\")\n            .toolbar {\n                Button(\"Cancel\") {\n                    presentationMode.wrappedValue.dismiss()\n                }\n            }\n        }\n    }\n}\n```\n\n4. Create EditDestinationView:\n```swift\nstruct EditDestinationView: View {\n    @State private var editedDestination: SyncDestination\n    @Environment(\\.presentationMode) var presentationMode\n    \n    let onSave: (SyncDestination) -> Void\n    \n    init(destination: SyncDestination, onSave: @escaping (SyncDestination) -> Void) {\n        self._editedDestination = State(initialValue: destination)\n        self.onSave = onSave\n    }\n    \n    var body: some View {\n        NavigationView {\n            Form {\n                Section(header: Text(\"Destination Details\")) {\n                    TextField(\"Name\", text: $editedDestination.name)\n                    \n                    Toggle(\"Enabled\", isOn: $editedDestination.isEnabled)\n                }\n                \n                Section {\n                    // Different configuration view based on destination type\n                    switch editedDestination.type {\n                    case .supabase:\n                        NavigationLink(\"Supabase Configuration\") {\n                            SupabaseConfigView(destination: $editedDestination)\n                        }\n                    case .googleSheets:\n                        NavigationLink(\"Google Sheets Configuration\") {\n                            GoogleSheetsConfigView(destination: $editedDestination)\n                        }\n                    case .zapier:\n                        NavigationLink(\"Zapier Configuration\") {\n                            ZapierConfigView(destination: $editedDestination)\n                        }\n                    case .customAPI:\n                        NavigationLink(\"Custom API Configuration\") {\n                            CustomAPIConfigView(destination: $editedDestination)\n                        }\n                    }\n                }\n                \n                Section {\n                    Button(\"Save\") {\n                        onSave(editedDestination)\n                    }\n                    .disabled(editedDestination.name.isEmpty)\n                }\n            }\n            .navigationTitle(\"Edit Destination\")\n            .toolbar {\n                Button(\"Cancel\") {\n                    presentationMode.wrappedValue.dismiss()\n                }\n            }\n        }\n    }\n}\n```",
        "testStrategy": "Create unit tests to verify:\n1. SyncDestinationsViewModel correctly interacts with SyncDestinationManager\n2. Proper handling of destination CRUD operations\n\nCreate UI tests to verify:\n1. Adding new destinations works correctly\n2. Editing destinations updates the configuration\n3. Deleting destinations removes them from the list\n4. Configuration views for each destination type function properly\n\nTest with various destination configurations to ensure the UI handles all cases correctly.",
        "priority": "high",
        "dependencies": [
          5,
          8,
          9,
          10
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Implement Settings Screen and App Finalization",
        "description": "Create the settings screen and finalize the app with proper error handling, documentation, and polish.",
        "details": "Implement the settings screen and finalize the app with proper error handling, documentation, and polish.\n\n1. Create SettingsView:\n```swift\nstruct SettingsView: View {\n    @StateObject private var viewModel = SettingsViewModel()\n    @State private var showingPrivacyPolicy = false\n    @State private var showingAbout = false\n    \n    var body: some View {\n        NavigationView {\n            Form {\n                Section(header: Text(\"Sync Settings\")) {\n                    Picker(\"Sync Frequency\", selection: $viewModel.syncFrequency) {\n                        Text(\"Manual Only\").tag(UserSettings.SyncFrequency.manual)\n                        Text(\"Daily\").tag(UserSettings.SyncFrequency.daily)\n                        Text(\"Hourly\").tag(UserSettings.SyncFrequency.hourly)\n                    }\n                    .onChange(of: viewModel.syncFrequency) { newValue in\n                        viewModel.updateSyncFrequency(newValue)\n                    }\n                    \n                    if viewModel.syncFrequency != .manual {\n                        Text(\"Background sync is subject to iOS system limitations and may not run exactly on schedule.\")\n                            .font(.caption)\n                            .foregroundColor(.secondary)\n                    }\n                    \n                    if let lastSync = viewModel.lastSyncDate {\n                        LabeledContent(\"Last Sync\", value: viewModel.formattedLastSync)\n                    }\n                }\n                \n                Section(header: Text(\"Health Data\")) {\n                    Button(\"Reauthorize HealthKit\") {\n                        viewModel.reauthorizeHealthKit()\n                    }\n                    \n                    Button(\"Refresh Available Metrics\") {\n                        viewModel.refreshAvailableMetrics()\n                    }\n                }\n                \n                Section(header: Text(\"Data Management\")) {\n                    Button(\"Clear Sync Logs\") {\n                        viewModel.clearLogs()\n                    }\n                    .foregroundColor(.red)\n                    \n                    Button(\"Reset All Settings\") {\n                        viewModel.showResetConfirmation = true\n                    }\n                    .foregroundColor(.red)\n                }\n                \n                Section(header: Text(\"About\")) {\n                    Button(\"Privacy Policy\") {\n                        showingPrivacyPolicy = true\n                    }\n                    \n                    Button(\"About HealthSync\") {\n                        showingAbout = true\n                    }\n                    \n                    LabeledContent(\"Version\", value: viewModel.appVersion)\n                }\n            }\n            .navigationTitle(\"Settings\")\n            .alert(\"Reset All Settings\", isPresented: $viewModel.showResetConfirmation) {\n                Button(\"Cancel\", role: .cancel) { }\n                Button(\"Reset\", role: .destructive) {\n                    viewModel.resetAllSettings()\n                }\n            } message: {\n                Text(\"This will reset all settings, destinations, and logs. This action cannot be undone.\")\n            }\n            .sheet(isPresented: $showingPrivacyPolicy) {\n                PrivacyPolicyView()\n            }\n            .sheet(isPresented: $showingAbout) {\n                AboutView()\n            }\n            .alert(isPresented: $viewModel.showingAlert) {\n                Alert(\n                    title: Text(viewModel.alertTitle),\n                    message: Text(viewModel.alertMessage),\n                    dismissButton: .default(Text(\"OK\"))\n                )\n            }\n        }\n    }\n}\n```\n\n2. Create SettingsViewModel:\n```swift\nclass SettingsViewModel: ObservableObject {\n    @Published var syncFrequency: UserSettings.SyncFrequency\n    @Published var lastSyncDate: Date?\n    @Published var showResetConfirmation = false\n    @Published var showingAlert = false\n    @Published var alertTitle = \"\"\n    @Published var alertMessage = \"\"\n    \n    private let configService = ConfigService.shared\n    private let healthKitManager = HealthKitManager.shared\n    private let logger = Logger.shared\n    \n    var appVersion: String {\n        return Bundle.main.infoDictionary?[\"CFBundleShortVersionString\"] as? String ?? \"Unknown\"\n    }\n    \n    var formattedLastSync: String {\n        guard let date = lastSyncDate else { return \"Never\" }\n        \n        let formatter = DateFormatter()\n        formatter.dateStyle = .medium\n        formatter.timeStyle = .short\n        return formatter.string(from: date)\n    }\n    \n    init() {\n        self.syncFrequency = configService.settings.syncFrequency\n        self.lastSyncDate = configService.settings.lastSyncDate\n    }\n    \n    func updateSyncFrequency(_ frequency: UserSettings.SyncFrequency) {\n        var settings = configService.settings\n        settings.syncFrequency = frequency\n        configService.updateSettings(settings)\n        \n        // Configure background tasks based on frequency\n        if frequency != .manual {\n            configureBackgroundTasks(for: frequency)\n        } else {\n            disableBackgroundTasks()\n        }\n    }\n    \n    func reauthorizeHealthKit() {\n        Task {\n            do {\n                let authorized = try await healthKitManager.requestAuthorization()\n                DispatchQueue.main.async {\n                    self.showAlert(\n                        title: authorized ? \"Success\" : \"Authorization Failed\",\n                        message: authorized ? \"HealthKit access has been reauthorized.\" : \"Unable to get authorization for HealthKit.\"\n                    )\n                }\n            } catch {\n                DispatchQueue.main.async {\n                    self.showAlert(\n                        title: \"Error\",\n                        message: \"Failed to reauthorize HealthKit: \\(error.localizedDescription)\"\n                    )\n                }\n            }\n        }\n    }\n    \n    func refreshAvailableMetrics() {\n        // This will trigger a refresh of available metrics in the HealthKitManager\n        // and update the UI accordingly\n        Task {\n            do {\n                let authorized = try await healthKitManager.requestAuthorization()\n                guard authorized else {\n                    DispatchQueue.main.async {\n                        self.showAlert(\n                            title: \"Authorization Failed\",\n                            message: \"Unable to get authorization for HealthKit.\"\n                        )\n                    }\n                    return\n                }\n                \n                // Refresh available types\n                let types = healthKitManager.fetchAvailableDataTypes()\n                \n                DispatchQueue.main.async {\n                    self.showAlert(\n                        title: \"Metrics Refreshed\",\n                        message: \"Found \\(types.count) available health metrics.\"\n                    )\n                }\n            } catch {\n                DispatchQueue.main.async {\n                    self.showAlert(\n                        title: \"Error\",\n                        message: \"Failed to refresh metrics: \\(error.localizedDescription)\"\n                    )\n                }\n            }\n        }\n    }\n    \n    func clearLogs() {\n        logger.clearLogs()\n        showAlert(\n            title: \"Logs Cleared\",\n            message: \"All sync logs have been cleared.\"\n        )\n    }\n    \n    func resetAllSettings() {\n        // Clear UserDefaults\n        if let bundleID = Bundle.main.bundleIdentifier {\n            UserDefaults.standard.removePersistentDomain(forName: bundleID)\n        }\n        \n        // Reinitialize services\n        syncFrequency = .manual\n        lastSyncDate = nil\n        \n        showAlert(\n            title: \"Settings Reset\",\n            message: \"All settings have been reset to defaults.\"\n        )\n    }\n    \n    private func showAlert(title: String, message: String) {\n        alertTitle = title\n        alertMessage = message\n        showingAlert = true\n    }\n    \n    private func configureBackgroundTasks(for frequency: UserSettings.SyncFrequency) {\n        // This would be implemented to register background tasks\n        // using BGTaskScheduler for iOS 13+\n        // For MVP, this is a placeholder\n    }\n    \n    private func disableBackgroundTasks() {\n        // This would be implemented to cancel background tasks\n        // For MVP, this is a placeholder\n    }\n}\n```\n\n3. Create AboutView and PrivacyPolicyView:\n```swift\nstruct AboutView: View {\n    var body: some View {\n        NavigationView {\n            ScrollView {\n                VStack(spacing: 20) {\n                    Image(\"AppIcon\")\n                        .resizable()\n                        .frame(width: 100, height: 100)\n                        .cornerRadius(20)\n                    \n                    Text(\"HealthSync\")\n                        .font(.largeTitle)\n                        .bold()\n                    \n                    Text(\"Version \\(Bundle.main.infoDictionary?[\"CFBundleShortVersionString\"] as? String ?? \"1.0\")\")\n                        .foregroundColor(.secondary)\n                    \n                    Text(\"HealthSync helps you take control of your health data by syncing Apple Health metrics to your preferred destinations.\")\n                        .multilineTextAlignment(.center)\n                        .padding()\n                    \n                    Divider()\n                    \n                    Text(\"Â© 2023 HealthSync Team\")\n                        .font(.caption)\n                        .foregroundColor(.secondary)\n                }\n                .padding()\n            }\n            .navigationTitle(\"About\")\n            .navigationBarTitleDisplayMode(.inline)\n            .toolbar {\n                Button(\"Done\") {\n                    // Dismiss sheet\n                }\n            }\n        }\n    }\n}\n\nstruct PrivacyPolicyView: View {\n    var body: some View {\n        NavigationView {\n            ScrollView {\n                VStack(alignment: .leading, spacing: 20) {\n                    Text(\"Privacy Policy\")\n                        .font(.title)\n                        .bold()\n                    \n                    Group {\n                        Text(\"HealthSync is designed with your privacy in mind. We believe your health data belongs to you, which is why our app:\")\n                        \n                        BulletPoint(text: \"Never stores your health data on our servers\")\n                        BulletPoint(text: \"Only syncs the specific metrics you choose\")\n                        BulletPoint(text: \"Keeps all processing on your device\")\n                        BulletPoint(text: \"Only sends data to destinations you configure\")\n                    }\n                    \n                    Group {\n                        Text(\"Data Collection\")\n                            .font(.headline)\n                        \n                        Text(\"HealthSync does not collect any analytics or usage data. The only data accessed is your Apple Health data, which is only processed on your device and only sent to the destinations you explicitly configure.\")\n                    }\n                    \n                    Group {\n                        Text(\"Third-Party Services\")\n                            .font(.headline)\n                        \n                        Text(\"When you configure sync destinations like Supabase, Google Sheets, or Zapier, your selected health data will be sent to these services. Please review the privacy policies of these third-party services for information on how they handle your data.\")\n                    }\n                }\n                .padding()\n            }\n            .navigationTitle(\"Privacy Policy\")\n            .navigationBarTitleDisplayMode(.inline)\n            .toolbar {\n                Button(\"Done\") {\n                    // Dismiss sheet\n                }\n            }\n        }\n    }\n}\n\nstruct BulletPoint: View {\n    let text: String\n    \n    var body: some View {\n        HStack(alignment: .top) {\n            Text(\"â€¢\")\n                .font(.headline)\n            Text(text)\n            Spacer()\n        }\n    }\n}\n```\n\n4. Final app polishing:\n   - Add app icons and launch screen\n   - Implement proper error handling throughout the app\n   - Add loading indicators for async operations\n   - Ensure accessibility support (VoiceOver, Dynamic Type)\n   - Add proper documentation in code\n   - Implement proper keyboard handling for form fields\n   - Add input validation for all user inputs\n   - Ensure proper state restoration for app backgrounding/foregrounding",
        "testStrategy": "Create unit tests to verify:\n1. SettingsViewModel correctly interacts with ConfigService\n2. Settings persistence across app restarts\n3. Reset functionality properly clears all settings\n\nCreate UI tests to verify:\n1. Settings screen displays correctly\n2. All buttons and controls function as expected\n3. Alert dialogs appear and function correctly\n\nPerform end-to-end testing of the entire app flow:\n1. Setting up HealthKit permissions\n2. Selecting metrics\n3. Configuring destinations\n4. Performing syncs\n5. Viewing logs\n6. Changing settings\n\nTest on multiple iOS versions (16+) and device types (iPhone and iPad) to ensure compatibility and responsiveness.",
        "priority": "medium",
        "dependencies": [
          3,
          4,
          7,
          11
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-07-05T10:15:45.833Z",
      "updated": "2025-07-05T10:15:45.833Z",
      "description": "Tasks for master context"
    }
  }
}